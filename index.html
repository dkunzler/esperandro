<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'/>
    <meta http-equiv="X-UA-Compatible" content="chrome=1"/>
    <meta name="description" content="Esperandro : Easy SharedPreference Engine foR ANDROid"/>

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Esperandro</title>
</head>

<body>

<!-- HEADER -->
<div id="header_wrap" class="outer">
    <header class="inner">
        <a id="forkme_banner" href="https://github.com/dkunzler/esperandro">View on GitHub</a>

        <h1 id="project_title">Esperandro</h1>

        <h2 id="project_tagline">Easy SharedPreference Engine foR ANDROid</h2>

        <section id="downloads">
            <a class="zip_download_link" href="https://github.com/dkunzler/esperandro/zipball/master">Download this
                project as a .zip file</a>
            <a class="tar_download_link" href="https://github.com/dkunzler/esperandro/tarball/master">Download this
                project as a tar.gz file</a>
        </section>
    </header>
</div>

<!-- MAIN CONTENT -->
<div id="main_content_wrap" class="outer">
<section id="main_content" class="inner">
<h1>
    <a name="esperandro" class="anchor" href="#esperandro"><span class="octicon octicon-link"></span></a>esperandro</h1>

<p>Easy SharedPreference Engine foR ANDROid</p>

<h2>What Is It?</h2>

<p>
    esperandro helps us Android developers using the <code>SharedPreferences</code> of the Android system. Normally
    there is a lot of boilerplate code when using them and we have
    to know everytime we are using a specific preference of which type it is. Furthermore we could potentially override
    existing preferences when using the same key twice.
</p>

<p>
    There comes esperandro to play. By defining which keys exist, along with their type, for each used named <code>SharedPreference</code>
    the usage of these preferences is both, typesafe and easy.<br/>
    For this purpose esperandro uses an Annotation Processor to generate a class implementing the defined interface at
    compile time.
    When storing and accessing preferences in the future, this generated class is used.
</p>

<h2>
    Usage
</h2>

<p>
    To work with esperandro we have to include the <a
        href="http://search.maven.org/remotecontent?filepath=de/devland/esperandro/esperandro-api/2.0.0/esperandro-api-2.0.0.jar">esperandro-api</a>
    in our Android App.
    The <a
        href="http://search.maven.org/remotecontent?filepath=de/devland/esperandro/esperandro/2.0.0/esperandro-2.0.0-jar-with-dependencies.jar">esperandro
    annotation processor</a> itself has to be in the classpath of the java compiler for annotation processing.
</p>

<h3>
    Defining Preferences
</h3>

<p>
    When defining the preferences used by our App we start with an emtpy interface and annotate it with <code>@SharedPreferences</code>.
    At this point we have two possibilities, either we don't specify any parameters at the annotation and end up with
    the default preferences,
    or we give them a name (and optionally a mode) to access a <code>SharedPreference</code> with the given name and
    mode.
</p>

<p>
    Something like

         <pre>
@SharedPreferences
public interface DefaultPreferences {</pre>
<br/>
would mimic a call as <code>PreferenceManager.getDefaultSharedPreferences(context)</code>.
</p>
<p>
    In contrast a definition like

         <pre>
@SharedPreferences(name = "eventPrefs", mode = SharedPreferenceMode.PRIVATE)
public interface EventPreferences {</pre>
<br/>
would mimic a call as <code>context.getSharedPreferences("eventPrefs", Context.MODE_PRIVATE)</code>. <br/>
The <i>mode</i> given here equivalents to the possible <code>Context.MODE_*</code> attributes. If no mode is given
explicitly,
<code>SharedPreferenceMode.PRIVATE</code> is assumed.
</p>

<h3>
    Getters and Setters for Preference Values
</h3>

<p>
    For each preference value of a given name there should be two methods in the interface. One getter and one setter.
    A getter returns the desired type of the preference. It's method name is the name that is used to retrieve the value
    from the
    <code>SharedPreference</code> object. It takes no further parameters.<br/>
    A setter returns <code>void</code> and takes exactly one parameter. This parameter but be the type that should be
    stored in the preference.
    Again the name of the method is the key used to access the underlying Android <code>SharedPreference</code> object.
</p>

<p>
    So for each value that should be stored in a specific <code>SharedPreference</code> we end up defining a pair of
    methods like:
         <pre>
String superFancyPreference();
void superFancyPreference(String superFancyPreferenceValue);</pre>
<br/>
The possible types are <code>int</code>, <code>long</code>, <code>float</code>, <code>boolean</code>,
<code>String</code> and <code>Set&lt;String&gt;</code>.
</p>

<p>
    As an alternative there is support for setters with a boolean return value. Esperandro will then return
    information about the success of the commit operation like documented in the <a
        href="http://developer.android.com/reference/android/content/SharedPreferences.Editor.html#commit()">official
    docs</a>.
</p>

<p>
	This looks like so:
	<pre>
boolean superFancyPreference(); // boolean getter
boolean superFancyPreference(boolean superFancyPreferenceValue); // boolean setter with information about success</pre>
</p>

<h3>
    Serialized object preferences
</h3>

<p>
    Sometimes it can be useful to not only be able to store primitive or <code>String</code> preferences but also
    objects.<br/>
    Esperandro provides an API for this use-case, too. There exists a <code>Serializer</code> interface that cat be
    implemented to be able to serialize and deserialize objects into a String preference.
</p>

<p>
    A <code>Serializer</code> can be set by calling <code>Esperandro.setSerializer(Serializer serializer)</code>. After
    this call all objects that are not compatible with Android's <code>SharedPreference</code>
    structure will be stored into a String preference using the previously set <code>Serializer</code>.
</p>

<p>
    If we don't want to provide our own <code>Serializer</code> we can use the <a
        href="http://search.maven.org/remotecontent?filepath=de/devland/esperandro/esperandro/2.0.0/esperandro-gson-addon-2.0.0-jar-with-dependencies.jar">esperandro
    gson addon</a>
    that will automatically be used to serialize objects if no other <code>Serializer</code> was set. This addon will
    serialize objects into a JSON string.
</p>
	If you are using Jackson in your project for JSON-Serialization there is the <a
        href="http://search.maven.org/remotecontent?filepath=de/devland/esperandro/esperandro/2.0.0/esperandro-jackson-addon-2.0.0-jar-with-dependencies.jar">esperandro
    jackson addon</a> that can be used.
<p>

</p>

<p>
    After setting our <code>Serializer</code> or adding one of the addons to the classpath we can use the
    following definition for object preferences:
		 <pre>
Container superFancyObjectPreference();
void superFancyObjectPreference(Container superFancyObjectPreferenceValue);</pre>
where <code>Container</code> ca be any class that can be serialized by your <code>Serializer</code> implementation.
</p>

<h3>
    Defaults
</h3>

<p>
    With no further configuration the following defaults apply when retrieving preference values that were not set
    before:
    <br/>
    <code>int</code> - <code>-1</code><br/>
    <code>long</code> - <code>-1l</code><br/>
    <code>float</code> - <code>-2.0.0f</code><br/>
    <code>boolean</code> - <code>false</code><br/>
    <code>String</code> - <code>""</code> (empty String)<br/>
    <code>Set&lt;String&gt;</code> - <code>null</code>
</p>

<p>
    For all types except <code>Set&lt;String&gt;</code> other defaults can be given using the <code>@Default</code>
    annotation.
    To make use of this mechanism the getter of a preference value has to be annotated with this annotation. The desired
    default can then be
    configured using the respective <code>of*</code> property of the annotation where * expands to the type of the
    getter.
</p>

<p>
    We then finally end up with something like
         <pre>
@Default(ofString = "superFancyDefaultValue")
String superFancyPreference();
void superFancyPreference(String superFancyPreferenceValue);</pre>
in our interface.
</p>

<h3>
    Runtime Defaults
</h3>

<p>
    In addtition to the annotated compile-time defaults, it is possible to provide runtime-defaults. To use them the getter method for a preference has to be specifically defined.
	Every getter that allows a runtime-default must not have the <code>@Default</code> annotation but instead end with <code>$Default</code> in the method name. The one and only parameter
	has to be of the type of the preference and resembles the given value that should be used as default.
</p>

<p>
	Example:
	
	<pre>
String superFancyPreference(); // getter with implicit compile-time-default

String superFancyPreference$Default(String defaultValue); // getter with runtime-default

void superFancyPreference(String superFancyPreferenceValue); // putter</pre>
</p>

<h3>
    Obtain Instance
</h3>

<p>
    Obtaining an instance of the generated class is easy. We just call
         <pre>
Esperandro.getPreferences(Class&lt;T&gt; preferenceClass, Context context)</pre>
<br/>
where <code>preferenceClass</code> is the Class of our interface.
</p>

<h3>
    Goodies
</h3>
<h4>
    Additional actions
</h4>

<p>
    All generated classes do not only implement our defined preference interface but also the <code>de.devland.esperandro.SharedPreferenceActions</code>
    interface. That means, if we let our interface extend it we have access to these convenience methods:
         <pre>
    /**
     * @return the underlying SharedPreference instance.
     */
    SharedPreferences get();

    /**
     * Checks if a value for the given key exists.
     * @param key
     * @return true if the given key exists, false otherwise
     */
    boolean contains(String key);
	
    /**
     * Removes the value for the given key.
     * @param key
     */
    void remove(String key);

    /**
     * Registers a callback to be invoked when a change happens to a preference.
     * @param listener The callback that will run.
     */
    void registerOnChangeListener(
            SharedPreferences.OnSharedPreferenceChangeListener listener);

    /**
     * Unregisters a previous callback.
     * @param listener The callback that should be unregistered.
     */
    void unregisterOnChangeListener(
            SharedPreferences.OnSharedPreferenceChangeListener listener);

    /**
     * Clears the complete sharedPreferences of the previously given name. (Be aware that ALL preferences under this
     * name are cleared not only the ones defined in your interface)
     */
    void clear();

    /**
     * Initializes the underlying SharedPreference object with the respective explicit or implicit default values. This
     * can be useful when the defaults should be shown in the summary in a PreferenceActivity.
     */
    void initDefaults();</pre>
</p>
<h4>
    Inheritance
</h4>

<p>
    If the annotated interface extends from other interfaces that define getters and putters for preferences, the
    generated class will implement them too. This way we can order the preferences hierarchically or even use common
    preference keys in different SharedPreference files.
</p>

<h2>
    Configure IDE
</h2>

<p>
    When configuring the IDE by hand you should download the
    <i><a href="http://search.maven.org/remotecontent?filepath=de/devland/esperandro/esperandro/2.0.0/esperandro-2.0.0-jar-with-dependencies.jar">jar-with-dependencies</a></i>
    bundle from <a href="http://search.maven.org/#search%7Cga%7C1%7Cesperandro">Maven central</a> and add this jar as
    annotation processor in your IDE.
</p>

<h3>
    Eclipse
</h3>

<p>
    Follow the instructions at <a
        href="http://help.eclipse.org/kepler/index.jsp?topic=%2Forg.eclipse.jdt.doc.isv%2Fguide%2Fjdt_apt_getting_started.htm">http://help.eclipse.org/</a>
    and
    add the downloaded jar-with-dependencies bundle as external jar in the dialog at the third screenshot.
</p>

<h3>
    IntelliJ IDEA
</h3>

<p>
    Follow the instruction at <a href="http://www.jetbrains.com/idea/webhelp/configuring-annotation-processing.html">http://www.jetbrains.com/</a>
    and choose at the third step the folder where you downloaded the jar-with-dependencies file.
</p>

<h2>
    Maven
</h2>

<p>
         <pre>
&lt;dependency&gt;
    &lt;groupId&gt;de.devland.esperandro&lt;/groupId&gt;
    &lt;artifactId&gt;esperandro-api&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;de.devland.esperandro&lt;/groupId&gt;
    &lt;artifactId&gt;esperandro&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency></pre>
</p>

<p>
    Optional, if we want to use object serialization but don't provide our own <code>Serializer</code>:
		 <pre>
&lt;dependency&gt;
    &lt;groupId&gt;de.devland.esperandro&lt;/groupId&gt;
    &lt;artifactId&gt;esperandro-gson-addon&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency></pre>

<h2>
    New Gradle Build System
</h2>

<p>
    The instructions below apply to the android gradle plugin version 0.10.+.
         <pre>
buildscript {
    repositories {
      mavenCentral()
    }
    dependencies {
        // Android plugin
        classpath 'com.android.tools.build:gradle:0.10.+'
        // the latest version of the android-apt plugin from https://bitbucket.org/hvisser/android-apt
        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.2'
    }
}

apply plugin: 'android'
apply plugin: 'android-apt'
		 
		 
repositories {
     mavenCentral();
}

dependencies {
    compile 'de.devland.esperandro:esperandro-api:2.0.0'
    apt 'de.devland.esperandro:esperandro:2.0.0'
	
    // optional, if we want to use object serialization but don't provide our own Serializer
    // compile 'de.devland.esperandro:esperandro-gson-addon:2.0.0'
	// or
	// compile 'de.devland.esperandro:esperandro-jackson-addon:2.0.0'
}
</pre>
</p>

<h2>
    Binaries Overview
</h2>

<p>
<ul>
    <li>
        <a href="http://search.maven.org/remotecontent?filepath=de/devland/esperandro/esperandro/2.0.0/esperandro-2.0.0-jar-with-dependencies.jar">esperandro</a>
        - The annotation processor itself. Do not include in final packaged application, just use at compile time.
    </li>
    <li>
        <a href="http://search.maven.org/remotecontent?filepath=de/devland/esperandro/esperandro-api/2.0.0/esperandro-api-2.0.0.jar">esperandro-api</a>
        - The annotations and interfaces needed at runtime. Include in the final package.
    </li>
    <li>
        <a href="http://search.maven.org/remotecontent?filepath=de/devland/esperandro/esperandro-gson-addon/2.0.0/esperandro-gson-addon-2.0.0-jar-with-dependencies.jar">esperandro-gson-addon</a>
        - A gson-Serializer for object preferences. Include in the final package if necessary.
    </li>
	<li>
        <a href="http://search.maven.org/remotecontent?filepath=de/devland/esperandro/esperandro-gson-addon/2.0.0/esperandro-jackson-addon-2.0.0-jar-with-dependencies.jar">esperandro-jackson-addon</a>
        - A jackson-Serializer for object preferences. Include in the final package if necessary.
    </li>
</ul>
</p>

<h2>
    License
</h2>

<p>
         <pre>
Copyright 2013 David Kunzler

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</pre>
</p>

</section>
</div>

<!-- FOOTER  -->
<div id="footer_wrap" class="outer">
    <footer class="inner">
        <p class="copyright">Esperandro maintained by <a href="https://github.com/dkunzler">dkunzler</a></p>

        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
    </footer>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-43265695-1', 'dkunzler.github.io');
        ga('send', 'pageview');

    </script>
</div>



</body>
</html>
